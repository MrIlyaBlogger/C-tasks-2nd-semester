#include <stdio.h>

// Определение структуры узла бинарного дерева
// Каждый узел содержит ключ и указатели на левого и правого потомков
typedef struct node {
    int key;                  // Значение (ключ) в узле
    struct node *left;        // Указатель на левого потомка
    struct node *right;       // Указатель на правого потомка
} tree;

// Рекурсивная функция для подсчёта количества узлов, не равных заданному значению k
// Возвращает количество таких узлов в дереве
int count_diff(tree *root, int k) {
    if (root == NULL)
        return 0; // Если дошли до пустого поддерева — возвращаем 0
    int count = 0;
    if (root->key != k) {
        count = 1; // Если значение в узле не равно k — увеличиваем счётчик
    }
    // Суммируем количество таких узлов в левом и правом поддереве
    return count + count_diff(root->left, k) + count_diff(root->right, k);
}

// Ниже - визуализация (на зачёте не пишем)

int main() {
    // Создаём дерево:
    //       5
    //      / \
    //     3   7
    //    /   / \
    //   3   5   8
    tree n1 = {3, NULL, NULL};         // Лист с ключом 3
    tree n2 = {3, &n1, NULL};          // Узел с ключом 3, левый потомок — n1
    tree n3 = {5, NULL, NULL};         // Лист с ключом 5
    tree n4 = {8, NULL, NULL};         // Лист с ключом 8
    tree n5 = {7, &n3, &n4};           // Узел с ключом 7, потомки — n3 и n4
    tree root = {5, &n2, &n5};         // Корень дерева с ключом 5

    int k = 3;
    int diff = count_diff(&root, k); // Считаем количество узлов, не равных 3
    printf("Количество узлов, не равных %d: %d\n", k, diff);

    k = 5;
    diff = count_diff(&root, k);     // Считаем количество узлов, не равных 5
    printf("Количество узлов, не равных %d: %d\n", k, diff);

    return 0;
}
